#!/bin/bash
#===============================================================================
# JPS Sync Migrations - Sync migration backups from Google Drive
#
# Syncs backup files from Google Drive to the local migrations/incoming directory
# using rclone. Requires rclone to be configured with a Google Drive remote.
#
# Usage:
#   jps-sync-migrations [--list] [--dry-run] [--verbose]
#
# Exit Codes:
#   0 - Success
#   1 - Sync failed
#   2 - Invalid arguments
#   3 - rclone not configured
#===============================================================================

set -eo pipefail

# Script metadata
readonly SCRIPT_NAME="jps-sync-migrations"
readonly SCRIPT_VERSION="1.0.0"

# Resolve the actual script location (handle symlinks)
_resolve_script_dir() {
    local source="${BASH_SOURCE[0]}"
    while [[ -L "$source" ]]; do
        local dir
        dir=$(cd -P "$(dirname "$source")" && pwd)
        source=$(readlink "$source")
        [[ $source != /* ]] && source="$dir/$source"
    done
    cd -P "$(dirname "$source")" && pwd
}

readonly SCRIPT_DIR="$(_resolve_script_dir)"
readonly INSTALL_DIR="$(dirname "$SCRIPT_DIR")"

# Source common library
if [[ -f "${INSTALL_DIR}/lib/jps-common.sh" ]]; then
    # shellcheck source=../lib/jps-common.sh
    source "${INSTALL_DIR}/lib/jps-common.sh"
else
    echo "[ERROR] Cannot find jps-common.sh library" >&2
    exit 2
fi

# Load configuration
load_config

#===============================================================================
# DEFAULTS AND CONFIGURATION
#===============================================================================

# Default Google Drive settings (can be overridden in jps-tools.conf)
GDRIVE_REMOTE_NAME="${GDRIVE_REMOTE_NAME:-gdrive}"
GDRIVE_MIGRATION_PATH="${GDRIVE_MIGRATION_PATH:-backups/_jps.migration.backups}"

# Local destination
LOCAL_INCOMING_DIR="/var/backups/jps/migrations/incoming"

#===============================================================================
# HELP AND VERSION
#===============================================================================

show_help() {
    cat << 'EOF'
JPS Sync Migrations - Sync migration backups from Google Drive

DESCRIPTION:
    Syncs backup files from a configured Google Drive folder to the local
    migrations/incoming directory using rclone. This enables a workflow where
    backups are placed in Google Drive and pulled to the server with one click.

USAGE:
    jps-sync-migrations [OPTIONS]

OPTIONS:
    -h, --help          Show this help message
    -V, --version       Show version information
    -l, --list          List available backups in Google Drive (no sync)
    -n, --dry-run       Show what would be synced without syncing
    -c, --clear         Clear incoming directory before sync (default)
    --no-clear          Don't clear incoming directory before sync
    --progress          Output JSON progress updates (for automation)
    -v, --verbose       Show detailed output
    -q, --quiet         Minimal output

CONFIGURATION:
    Settings in /opt/jps-server-tools/etc/jps-tools.conf:
      GDRIVE_REMOTE_NAME  - rclone remote name (default: gdrive)
      GDRIVE_MIGRATION_PATH - Path in Google Drive (default: backups/_jps.migration.backups)

SETUP:
    1. Install rclone: curl https://rclone.org/install.sh | sudo bash
    2. Configure Google Drive: rclone config
       - Create remote named "gdrive" (or your GDRIVE_REMOTE_NAME)
       - Type: drive
       - Follow OAuth flow in browser

EXAMPLES:
    # List available backups in Google Drive
    jps-sync-migrations --list

    # Sync backups (clears incoming first)
    jps-sync-migrations

    # Preview what would be synced
    jps-sync-migrations --dry-run

    # Sync with JSON progress (for admin panel)
    jps-sync-migrations --progress

EXIT CODES:
    0 - Success
    1 - Sync failed
    2 - Invalid arguments
    3 - rclone not configured

For more information, see: https://github.com/yourusername/jps-server-tools
EOF
}

show_version() {
    echo "$SCRIPT_NAME version $SCRIPT_VERSION"
}

#===============================================================================
# GLOBAL VARIABLES
#===============================================================================

LIST_MODE=false
DRY_RUN=false
CLEAR_FIRST=true
PROGRESS_OUTPUT=false
VERBOSE=false
QUIET=false

#===============================================================================
# OUTPUT FUNCTIONS
#===============================================================================

progress() {
    local step="$1"
    local status="$2"
    local message="$3"
    shift 3

    if [[ "$PROGRESS_OUTPUT" == true ]]; then
        # Build JSON object with additional fields
        local json="{\"step\":\"${step}\",\"status\":\"${status}\",\"message\":\"${message}\""
        while [[ $# -gt 0 ]]; do
            local key="$1"
            local value="$2"
            # Check if value is numeric
            if [[ "$value" =~ ^[0-9]+$ ]]; then
                json+=",\"${key}\":${value}"
            else
                json+=",\"${key}\":\"${value}\""
            fi
            shift 2
        done
        json+="}"
        echo "$json"
    elif [[ "$QUIET" != true ]]; then
        case "$status" in
            start)    info "$message" ;;
            complete) success "$message" ;;
            error)    error "$message" ;;
            progress) echo "  $message" ;;
            *)        echo "  $message" ;;
        esac
    fi
}

log_verbose() {
    if [[ "$VERBOSE" == true ]] && [[ "$PROGRESS_OUTPUT" != true ]]; then
        echo "  [DEBUG] $*"
    fi
}

#===============================================================================
# ARGUMENT PARSING
#===============================================================================

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -V|--version)
                show_version
                exit 0
                ;;
            -l|--list)
                LIST_MODE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -c|--clear)
                CLEAR_FIRST=true
                shift
                ;;
            --no-clear)
                CLEAR_FIRST=false
                shift
                ;;
            --progress)
                PROGRESS_OUTPUT=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            -*)
                error "Unknown option: $1"
                echo "Use --help for usage information" >&2
                exit 2
                ;;
            *)
                error "Unexpected argument: $1"
                exit 2
                ;;
        esac
    done
}

#===============================================================================
# RCLONE CHECKS
#===============================================================================

check_rclone_installed() {
    if ! command -v rclone &>/dev/null; then
        error "rclone is not installed"
        echo ""
        echo "Install rclone with:"
        echo "  curl https://rclone.org/install.sh | sudo bash"
        return 1
    fi
    log_verbose "rclone found: $(command -v rclone)"
    return 0
}

check_rclone_remote() {
    local remote="$GDRIVE_REMOTE_NAME"

    # Check if remote exists in rclone config
    if ! rclone listremotes 2>/dev/null | grep -q "^${remote}:$"; then
        error "rclone remote '${remote}' is not configured"
        echo ""
        echo "Configure rclone with:"
        echo "  rclone config"
        echo ""
        echo "Create a remote named '${remote}' of type 'drive' (Google Drive)"
        return 1
    fi

    log_verbose "rclone remote '${remote}' found"
    return 0
}

test_gdrive_connection() {
    local remote="$GDRIVE_REMOTE_NAME"
    local path="$GDRIVE_MIGRATION_PATH"

    log_verbose "Testing connection to ${remote}:${path}"

    # Try to list the directory (quick timeout)
    if ! timeout 30 rclone lsd "${remote}:${path}" &>/dev/null 2>&1; then
        # Directory might not exist yet, try parent
        local parent_path
        parent_path=$(dirname "$path")

        if ! timeout 30 rclone lsd "${remote}:${parent_path}" &>/dev/null 2>&1; then
            warn "Cannot access Google Drive path: ${path}"
            warn "The directory may not exist or rclone authorization may have expired"
            return 1
        fi
    fi

    log_verbose "Google Drive connection successful"
    return 0
}

#===============================================================================
# LIST GOOGLE DRIVE CONTENTS
#===============================================================================

list_gdrive_contents() {
    progress "list" "start" "Listing backups in Google Drive"

    local remote="$GDRIVE_REMOTE_NAME"
    local path="$GDRIVE_MIGRATION_PATH"

    # Get directory listing with sizes
    local listing
    listing=$(rclone lsf "${remote}:${path}" --format "sp" -R 2>/dev/null || echo "")

    if [[ -z "$listing" ]]; then
        progress "list" "complete" "No backups found in Google Drive"
        return 0
    fi

    # Parse and display
    local total_size=0
    local file_count=0
    local dir_count=0

    if [[ "$PROGRESS_OUTPUT" == true ]]; then
        # JSON output
        echo "{\"step\":\"list\",\"status\":\"complete\",\"items\":["
        local first=true

        while IFS= read -r line; do
            [[ -z "$line" ]] && continue

            # Format: size;path
            local size="${line%%;*}"
            local item_path="${line#*;}"

            # Determine if directory
            local is_dir=false
            if [[ "$item_path" == */ ]]; then
                is_dir=true
                ((dir_count++))
            else
                ((file_count++))
            fi

            # Convert size to human readable
            local human_size
            human_size=$(numfmt --to=iec-i --suffix=B "$size" 2>/dev/null || echo "${size}B")

            total_size=$((total_size + size))

            if [[ "$first" == true ]]; then
                first=false
            else
                echo ","
            fi

            echo -n "{\"path\":\"${item_path}\",\"size\":${size},\"human_size\":\"${human_size}\",\"is_dir\":${is_dir}}"
        done <<< "$listing"

        local total_human
        total_human=$(numfmt --to=iec-i --suffix=B "$total_size" 2>/dev/null || echo "${total_size}B")

        echo "],\"total_size\":${total_size},\"total_human\":\"${total_human}\",\"file_count\":${file_count},\"dir_count\":${dir_count}}"
    else
        # Human-readable output
        echo ""
        echo "Google Drive: ${remote}:${path}"
        echo "========================================"

        while IFS= read -r line; do
            [[ -z "$line" ]] && continue

            local size="${line%%;*}"
            local item_path="${line#*;}"

            local human_size
            human_size=$(numfmt --to=iec-i --suffix=B "$size" 2>/dev/null || echo "${size}B")

            total_size=$((total_size + size))

            if [[ "$item_path" == */ ]]; then
                ((dir_count++))
                printf "  üìÅ %-40s %10s\n" "$item_path" "$human_size"
            else
                ((file_count++))
                printf "  üìÑ %-40s %10s\n" "$item_path" "$human_size"
            fi
        done <<< "$listing"

        local total_human
        total_human=$(numfmt --to=iec-i --suffix=B "$total_size" 2>/dev/null || echo "${total_size}B")

        echo "========================================"
        echo "Total: $file_count files, $dir_count directories ($total_human)"
    fi

    return 0
}

#===============================================================================
# SYNC FROM GOOGLE DRIVE
#===============================================================================

clear_incoming_dir() {
    progress "clear" "start" "Clearing incoming directory"

    if [[ ! -d "$LOCAL_INCOMING_DIR" ]]; then
        mkdir -p "$LOCAL_INCOMING_DIR"
        log_verbose "Created incoming directory: $LOCAL_INCOMING_DIR"
    else
        # Remove contents but keep the directory
        rm -rf "${LOCAL_INCOMING_DIR:?}"/*
        log_verbose "Cleared incoming directory"
    fi

    progress "clear" "complete" "Incoming directory cleared"
    return 0
}

sync_from_gdrive() {
    progress "sync" "start" "Syncing from Google Drive"

    local remote="$GDRIVE_REMOTE_NAME"
    local path="$GDRIVE_MIGRATION_PATH"
    local source="${remote}:${path}"
    local dest="$LOCAL_INCOMING_DIR"

    # Ensure destination exists
    mkdir -p "$dest"

    # Build rclone command
    local rclone_cmd=(rclone copy "$source" "$dest")

    # Add options
    rclone_cmd+=(--progress)
    rclone_cmd+=(--stats-one-line)
    rclone_cmd+=(--stats 2s)

    if [[ "$DRY_RUN" == true ]]; then
        rclone_cmd+=(--dry-run)
    fi

    if [[ "$VERBOSE" == true ]]; then
        rclone_cmd+=(-v)
    fi

    log_verbose "Running: ${rclone_cmd[*]}"

    # Execute rclone and capture output
    local temp_output
    temp_output=$(mktemp)

    if [[ "$PROGRESS_OUTPUT" == true ]]; then
        # Parse rclone output for JSON progress
        "${rclone_cmd[@]}" 2>&1 | while IFS= read -r line; do
            # Parse rclone stats line
            # Format: "Transferred: 10 / 20, 50%"
            if [[ "$line" =~ Transferred:[[:space:]]*([0-9]+)[[:space:]]*/[[:space:]]*([0-9]+) ]]; then
                local transferred="${BASH_REMATCH[1]}"
                local total="${BASH_REMATCH[2]}"
                echo "{\"step\":\"sync\",\"status\":\"progress\",\"message\":\"Transferring files\",\"transferred\":${transferred},\"total\":${total}}"
            elif [[ "$line" =~ ([0-9.]+[[:space:]]*[KMGi]*B) ]]; then
                # Has size info
                echo "{\"step\":\"sync\",\"status\":\"progress\",\"message\":\"${line}\"}"
            fi
        done
    else
        "${rclone_cmd[@]}" 2>&1 | tee "$temp_output"
    fi

    local exit_code=${PIPESTATUS[0]}

    rm -f "$temp_output"

    if [[ $exit_code -ne 0 ]]; then
        progress "sync" "error" "Sync failed with exit code $exit_code"
        return 1
    fi

    # Count what we got
    local file_count=0
    local total_size=0

    if [[ -d "$dest" ]]; then
        file_count=$(find "$dest" -type f | wc -l)
        total_size=$(du -sb "$dest" 2>/dev/null | cut -f1 || echo "0")
    fi

    local human_size
    human_size=$(numfmt --to=iec-i --suffix=B "$total_size" 2>/dev/null || echo "${total_size}B")

    if [[ "$DRY_RUN" == true ]]; then
        progress "sync" "complete" "Dry run complete - no files transferred" \
            "file_count" "$file_count" "total_size" "$total_size" "human_size" "$human_size" "dry_run" "true"
    else
        progress "sync" "complete" "Synced $file_count files ($human_size)" \
            "file_count" "$file_count" "total_size" "$total_size" "human_size" "$human_size"
    fi

    return 0
}

#===============================================================================
# MAIN EXECUTION
#===============================================================================

main() {
    # Parse arguments
    parse_args "$@"

    # Header
    if [[ "$QUIET" != true ]] && [[ "$PROGRESS_OUTPUT" != true ]]; then
        header "JPS Sync Migrations"
        echo "Remote:      ${GDRIVE_REMOTE_NAME}:${GDRIVE_MIGRATION_PATH}"
        echo "Local:       ${LOCAL_INCOMING_DIR}"
        echo "Mode:        $(if [[ "$LIST_MODE" == true ]]; then echo "List"; elif [[ "$DRY_RUN" == true ]]; then echo "Dry Run"; else echo "Sync"; fi)"
        echo ""
    fi

    # Check rclone is installed
    progress "check" "start" "Checking rclone configuration"

    if ! check_rclone_installed; then
        progress "check" "error" "rclone is not installed"
        exit 3
    fi

    if ! check_rclone_remote; then
        progress "check" "error" "rclone remote not configured"
        exit 3
    fi

    if ! test_gdrive_connection; then
        progress "check" "error" "Cannot connect to Google Drive"
        exit 3
    fi

    progress "check" "complete" "rclone configured and connected"

    # List mode
    if [[ "$LIST_MODE" == true ]]; then
        list_gdrive_contents
        exit $?
    fi

    # Sync mode
    if [[ "$CLEAR_FIRST" == true ]] && [[ "$DRY_RUN" != true ]]; then
        clear_incoming_dir
    fi

    if ! sync_from_gdrive; then
        exit 1
    fi

    # Success summary
    if [[ "$QUIET" != true ]] && [[ "$PROGRESS_OUTPUT" != true ]]; then
        echo ""
        success "Sync complete!"
        echo ""
        echo "Files are ready in: $LOCAL_INCOMING_DIR"
        echo ""
        echo "Next steps:"
        echo "  1. Use 'Migrate Site' in admin panel to import the backup"
        echo "  2. Or run: jps-migrate-site --target example.com"
    fi

    exit 0
}

# Run main function
main "$@"
